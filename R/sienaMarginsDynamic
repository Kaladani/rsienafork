#/******************************************************************************
# * SIENA: Simulation Investigation for Empirical Network Analysis
# *
# * Web: https://www.stats.ox.ac.uk/~snijders/siena/
# *
# * File: sienaMargins.r
# *
# * Description: Calculates predicted edge probabilities and
# * (average) marginal effects for simulated chains
# *****************************************************************************/

##@sienaAMEDynamic
simAMEDynamic <- function(ans,
                            data,
                            effectName1,
                            diff1 = NULL,
                            contrast1 = NULL,
                            interaction1 = FALSE,
                            int_effectNames1 = NULL,
                            mod_effectNames1 = NULL,
                            effectName2 = NULL,
                            diff2 = NULL,
                            contrast2 = NULL,
                            interaction2 = FALSE,
                            int_effectNames2 = NULL,
                            mod_effectNames2 = NULL,
                            contNames,
                            effects,
                            tieProb = TRUE,
                            depvar = NULL,
                            second = FALSE,
                            level = "none",
                            condition = NULL,
                            sum.fun = mean,
                            na.rm = TRUE,
                            uncertainty = TRUE,
                            nsim = 1000,
                            useCluster = FALSE,
                            nbrNodes = 1,
                            clusterType = c("PSOCK", "FORK"),
                            cluster = NULL,
                            batch_dir = "temp",
                            prefix = "simBatch_b",
                            batch_size = 1,
                            combine_batch = TRUE,
                            keep_batch = FALSE,
                            verbose = TRUE){
  if(!second){
    sim_fun <- simFirstDiffDynamic
    sim_args <- list(
      ans = ans,
      data = data,
      effectName = effectName1,
      diff = diff1,
      contrast = contrast1,
      interaction = interaction1,
      int_effectNames = int_effectNames1,
      mod_effectNames = mod_effectNames1,
      contNames = contNames,
      effects = effects,
      tieProb = tieProb,
      depvar = depvar,
      sim_theta = TRUE,
      level = level,
      condition = condition,
      sum.fun = sum.fun,
      na.rm = na.rm
    )
    ME <- "firstDiff"
  }else{
    sim_fun <- simSecondDiffDynamic
    sim_args <- list(
      ans = ans,
      data = data,
      effectName1 = effectName1,
      diff1 = diff1,
      contrast1 = contrast1,
      interaction1 = interaction1,
      int_effectNames1 = int_effectNames1,
      mod_effectNames1 = mod_effectNames1,
      effectName2 = effectName2,
      diff2 = diff2,
      contrast2 = contrast2,
      interaction2 = interaction2,
      int_effectNames2 = int_effectNames2,
      mod_effectNames2 = mod_effectNames2,
      contNames = contNames,
      effects = effects,
      tieProb = tieProb,
      depvar = depvar,
      sim_theta = TRUE,
      level = level,
      condition = condition,
      sum.fun = sum.fun,
      na.rm = na.rm
    )
    ME <- "secondDiff"
  }
  
  if(!useCluster){
    # not nice, but works since mclapply reduces to lapply for nbrNodes = 1
    clusterType <- "FORK" 
    nbrNodes <- 1
  }
  
  # Point estimate
  sim_args_theta <- sim_args
  sim_args_theta$sim_theta <- FALSE

  point_AME <- do.call(sim_fun, sim_args_theta)
  
  if(!uncertainty){
    return(point_AME)
  }else{
    uncert_AME <- drawSim(
      sim_fun = sim_fun,
      sim_args = sim_args,
      nbrNodes = nbrNodes,
      nsim = nsim,
      clusterType = clusterType,
      cluster = cluster,
      batch_dir = batch_dir,
      prefix = prefix,
      batch_size = batch_size,
      combine_batch = combine_batch,
      keep_batch = keep_batch,
      verbose = verbose
    )
    
    uncert_AME <- agg(ME, uncert_AME, level = level, condition = condition, sum.fun = summarizeValue)
    
    if(is.null(condition)){
      return(cbind(point_AME, uncert_AME)) # merge would be safer, but does not handle results without id vars well
    } else {
      return(merge(point_AME, uncert_AME))
    }
  }
}

simFirstDiffDynamic <- function(ans, data, effectName, 
                                diff = NULL, contrast = NULL, 
                                interaction = FALSE,
                                int_effectNames = NULL,
                                mod_effectNames = NULL,
                                contNames, effects, 
                                tieProb = TRUE,
                                depvar = NULL,
                                sim_theta = TRUE,
                                aggregateValues = TRUE,
                                level = "none",
                                condition = NULL,
                                sum.fun = mean,
                                na.rm = TRUE){
  if(is.null(depvar)){
    depvar <- names(data$depvars)[1]
  }
  n_choices <- dim(data[["depvars"]][[depvar]])[2]
  
  if(sim_theta){
    ## might not work with estimated rate effects
    theta <- MASS::mvrnorm(n=1,
                               mu = ans$theta,
                               Sigma = ans$covtheta)
    ## add option to change algorithm -> number of chains -> 
  }else{
    theta <- ans$theta
  }

  cont_df <- calculateContributionsDynamic(
    data = data,  
    theta = c(ans$rate, theta),
    algorithm = ans$x,
    effects = effects,
    depvar = depvar
  )
  
  prob_sim <- as.data.frame(cont_df)

  prob_sim[,"changeUtil"] <- calculateUtility(prob_sim[,contNames], theta)

  prob_sim <- as.data.table(prob_sim)
  prob_sim[, changeProb := {
    ex <- exp(changeUtil - max(changeUtil))
    ex / sum(ex)
  }, by = .(chain, period, ministep)]
  prob_sim <- as.data.frame(prob_sim)
  
  # prob_sim[,"changeProb"] <- with(prob_sim, ave(changeUtil, chain, period, ministep, FUN = softmax))
  # grp <- with(prob_sim, interaction(chain, period, ministep, drop=TRUE))
  # 
  # # Compute grouped softmax using lapply
  # prob_sim[,"changeProb"] <- with(prob_sim, unsplit(
  #   lapply(split(changeUtil, grp), softmax),
  #   grp
  #   )
  # )

  # density == 0 is only relevant for the normalizing constant, not needed for difference calculation
  prob_sim <- subset(prob_sim, density != 0)
  
  if(tieProb == TRUE){
    prob_sim[,"tieProb"] <- prob_sim[,"changeProb"]
    prob_sim[prob_sim[,"density"] == -1,"tieProb"] <- 1 - prob_sim[prob_sim[,"density"] == -1,"changeProb"]
  }

  firstDiff_sim <- calculateFirstDiff(prob_sim, effectName = effectName, diff = diff, contrast = contrast,
                                      interaction = interaction,
                                      int_effectNames = int_effectNames,
                                      mod_effectNames = mod_effectNames,
                                      theta = theta,
                                      tieProb = tieProb,
                                      contNames = contNames)

  # Transform contributions to change statistics for aggregation and output
  prob_sim[prob_sim[, "density"] == -1, setdiff(contNames, "density")] <- prob_sim[prob_sim[, "density"] == -1, setdiff(contNames, "density")] * -1
  
  firstDiff_sim <- cbind(prob_sim, firstDiff_sim) ## probably inefficient
  
  if(aggregateValues) {
    firstDiff_sim <- agg("firstDiff",
                            firstDiff_sim,
                            level = level,
                            condition = condition,
                            sum.fun = sum.fun,
                            na.rm = TRUE)
  }
  firstDiff_sim
}

simSecondDiffDynamic <- function(ans, data, effectName1,
                                diff1 = NULL, contrast1 = NULL,
                                interaction1 = FALSE,
                                int_effectNames1 = NULL,
                                mod_effectNames1 = NULL,
                                effectName2,
                                diff2 = NULL, contrast2 = NULL,
                                interaction2 = FALSE,
                                int_effectNames2 = NULL,
                                mod_effectNames2 = NULL,
                                contNames, effects,
                                tieProb = TRUE,
                                depvar = NULL,
                                sim_theta = TRUE,
                                aggregateValues = TRUE,
                                level = "none",
                                condition = NULL,
                                sum.fun = mean,
                                na.rm = TRUE){
  if(is.null(depvar)){
    depvar <- names(data$depvars)[1]
  }
  n_choices <- dim(data[["depvars"]][[depvar]])[2]

  if(sim_theta){
    ## might not work with estimated rate effects
    theta <- MASS::mvrnorm(n=1,
                               mu = ans$theta,
                               Sigma = ans$covtheta)
    ## add option to change algorithm -> number of chains -> 
  }else{
    theta <- ans$theta
  }

  cont_df <- calculateContributionsDynamic(
    data = data,
    theta = c(ans$rate, theta),
    algorithm = ans$x,
    effects = effects,
    depvar = depvar
  )

  prob_sim <- as.data.frame(cont_df)

  prob_sim[,"changeUtil"] <- calculateUtility(prob_sim[,contNames], theta)

  prob_sim <- as.data.table(prob_sim)
  prob_sim[, changeProb := {
    ex <- exp(changeUtil - max(changeUtil))
    ex / sum(ex)
  }, by = .(chain, period, ministep)]
  prob_sim <- as.data.frame(prob_sim)

  # The following solutions only depend on base R but are inefficient for large data
  # prob_sim[,"changeProb"] <- with(prob_sim, ave(changeUtil, chain, period, ministep, FUN = softmax))
  # grp <- with(prob_sim, interaction(chain, period, ministep, drop=TRUE))
  #
  # # Compute grouped softmax using lapply
  # prob_sim[,"changeProb"] <- with(prob_sim, unsplit(
  #   lapply(split(changeUtil, grp), softmax),
  #   grp
  #   )
  # )

  # density == 0 is only relevant for the normalizing constant, not needed for difference calculation
  prob_sim <- subset(prob_sim, density != 0)
  
  if(tieProb == TRUE){
    prob_sim[,"tieProb"] <- prob_sim[,"changeProb"]
    prob_sim[prob_sim[,"density"] == -1,"tieProb"] <- 1 - prob_sim[prob_sim[,"density"] == -1,"changeProb"]
  }

  secondDiff_sim <- calculateSecondDiff(prob_sim,
                                      effectName1 = effectName1, diff1 = diff1, contrast1 = contrast1,
                                      interaction1 = interaction1,
                                      int_effectNames1 = int_effectNames1,
                                      mod_effectNames1 = mod_effectNames1,
                                      effectName2 = effectName2, diff2 = diff2, contrast2 = contrast2,
                                      interaction2 = interaction2,
                                      int_effectNames2 = int_effectNames2,
                                      mod_effectNames2 = mod_effectNames2,
                                      theta = theta,
                                      tieProb = tieProb,
                                      contNames = contNames)

  # Transform contributions to change statistics for aggregation and output
  prob_sim[prob_sim[, "density"] == -1, setdiff(contNames, "density")] <- prob_sim[prob_sim[, "density"] == -1, setdiff(contNames, "density")] * -1
  secondDiff_sim <- cbind(prob_sim, secondDiff_sim)
  
    if(aggregateValues) {
    secondDiff_sim <- agg("secondDiff",
                            secondDiff_sim,
                            level = level,
                            condition = condition,
                            sum.fun = sum.fun,
                            na.rm = TRUE)
  }
  secondDiff_sim
}
